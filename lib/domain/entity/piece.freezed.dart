// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'piece.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PieceTearOff {
  const _$PieceTearOff();

  Huhyo huhyo() {
    return const Huhyo();
  }

  Tokin tokin() {
    return const Tokin();
  }

  Kyosha kyosha() {
    return const Kyosha();
  }

  Narikyo narikyo() {
    return const Narikyo();
  }

  Keima keima() {
    return const Keima();
  }

  Narikei narikei() {
    return const Narikei();
  }

  Ginsho ginsho() {
    return const Ginsho();
  }

  Narigin narigin() {
    return const Narigin();
  }

  Hisha hisha() {
    return const Hisha();
  }

  Ryuo ryuo() {
    return const Ryuo();
  }

  Kakugyo kakugyo() {
    return const Kakugyo();
  }

  Ryuma ryuma() {
    return const Ryuma();
  }

  Kinsho kinsho() {
    return const Kinsho();
  }

  Ousho ousho() {
    return const Ousho();
  }

  Gyokusho gyokusho() {
    return const Gyokusho();
  }
}

/// @nodoc
const $Piece = _$PieceTearOff();

/// @nodoc
mixin _$Piece {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PieceCopyWith<$Res> {
  factory $PieceCopyWith(Piece value, $Res Function(Piece) then) =
      _$PieceCopyWithImpl<$Res>;
}

/// @nodoc
class _$PieceCopyWithImpl<$Res> implements $PieceCopyWith<$Res> {
  _$PieceCopyWithImpl(this._value, this._then);

  final Piece _value;
  // ignore: unused_field
  final $Res Function(Piece) _then;
}

/// @nodoc
abstract class $HuhyoCopyWith<$Res> {
  factory $HuhyoCopyWith(Huhyo value, $Res Function(Huhyo) then) =
      _$HuhyoCopyWithImpl<$Res>;
}

/// @nodoc
class _$HuhyoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $HuhyoCopyWith<$Res> {
  _$HuhyoCopyWithImpl(Huhyo _value, $Res Function(Huhyo) _then)
      : super(_value, (v) => _then(v as Huhyo));

  @override
  Huhyo get _value => super._value as Huhyo;
}

/// @nodoc

class _$Huhyo extends Huhyo {
  const _$Huhyo() : super._();

  @override
  String toString() {
    return 'Piece.huhyo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Huhyo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return huhyo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return huhyo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (huhyo != null) {
      return huhyo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return huhyo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return huhyo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (huhyo != null) {
      return huhyo(this);
    }
    return orElse();
  }
}

abstract class Huhyo extends Piece {
  const factory Huhyo() = _$Huhyo;
  const Huhyo._() : super._();
}

/// @nodoc
abstract class $TokinCopyWith<$Res> {
  factory $TokinCopyWith(Tokin value, $Res Function(Tokin) then) =
      _$TokinCopyWithImpl<$Res>;
}

/// @nodoc
class _$TokinCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $TokinCopyWith<$Res> {
  _$TokinCopyWithImpl(Tokin _value, $Res Function(Tokin) _then)
      : super(_value, (v) => _then(v as Tokin));

  @override
  Tokin get _value => super._value as Tokin;
}

/// @nodoc

class _$Tokin extends Tokin {
  const _$Tokin() : super._();

  @override
  String toString() {
    return 'Piece.tokin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Tokin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return tokin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return tokin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (tokin != null) {
      return tokin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return tokin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return tokin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (tokin != null) {
      return tokin(this);
    }
    return orElse();
  }
}

abstract class Tokin extends Piece {
  const factory Tokin() = _$Tokin;
  const Tokin._() : super._();
}

/// @nodoc
abstract class $KyoshaCopyWith<$Res> {
  factory $KyoshaCopyWith(Kyosha value, $Res Function(Kyosha) then) =
      _$KyoshaCopyWithImpl<$Res>;
}

/// @nodoc
class _$KyoshaCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $KyoshaCopyWith<$Res> {
  _$KyoshaCopyWithImpl(Kyosha _value, $Res Function(Kyosha) _then)
      : super(_value, (v) => _then(v as Kyosha));

  @override
  Kyosha get _value => super._value as Kyosha;
}

/// @nodoc

class _$Kyosha extends Kyosha {
  const _$Kyosha() : super._();

  @override
  String toString() {
    return 'Piece.kyosha()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Kyosha);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return kyosha();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return kyosha?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (kyosha != null) {
      return kyosha();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return kyosha(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return kyosha?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (kyosha != null) {
      return kyosha(this);
    }
    return orElse();
  }
}

abstract class Kyosha extends Piece {
  const factory Kyosha() = _$Kyosha;
  const Kyosha._() : super._();
}

/// @nodoc
abstract class $NarikyoCopyWith<$Res> {
  factory $NarikyoCopyWith(Narikyo value, $Res Function(Narikyo) then) =
      _$NarikyoCopyWithImpl<$Res>;
}

/// @nodoc
class _$NarikyoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $NarikyoCopyWith<$Res> {
  _$NarikyoCopyWithImpl(Narikyo _value, $Res Function(Narikyo) _then)
      : super(_value, (v) => _then(v as Narikyo));

  @override
  Narikyo get _value => super._value as Narikyo;
}

/// @nodoc

class _$Narikyo extends Narikyo {
  const _$Narikyo() : super._();

  @override
  String toString() {
    return 'Piece.narikyo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Narikyo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return narikyo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return narikyo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (narikyo != null) {
      return narikyo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return narikyo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return narikyo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (narikyo != null) {
      return narikyo(this);
    }
    return orElse();
  }
}

abstract class Narikyo extends Piece {
  const factory Narikyo() = _$Narikyo;
  const Narikyo._() : super._();
}

/// @nodoc
abstract class $KeimaCopyWith<$Res> {
  factory $KeimaCopyWith(Keima value, $Res Function(Keima) then) =
      _$KeimaCopyWithImpl<$Res>;
}

/// @nodoc
class _$KeimaCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $KeimaCopyWith<$Res> {
  _$KeimaCopyWithImpl(Keima _value, $Res Function(Keima) _then)
      : super(_value, (v) => _then(v as Keima));

  @override
  Keima get _value => super._value as Keima;
}

/// @nodoc

class _$Keima extends Keima {
  const _$Keima() : super._();

  @override
  String toString() {
    return 'Piece.keima()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Keima);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return keima();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return keima?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (keima != null) {
      return keima();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return keima(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return keima?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (keima != null) {
      return keima(this);
    }
    return orElse();
  }
}

abstract class Keima extends Piece {
  const factory Keima() = _$Keima;
  const Keima._() : super._();
}

/// @nodoc
abstract class $NarikeiCopyWith<$Res> {
  factory $NarikeiCopyWith(Narikei value, $Res Function(Narikei) then) =
      _$NarikeiCopyWithImpl<$Res>;
}

/// @nodoc
class _$NarikeiCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $NarikeiCopyWith<$Res> {
  _$NarikeiCopyWithImpl(Narikei _value, $Res Function(Narikei) _then)
      : super(_value, (v) => _then(v as Narikei));

  @override
  Narikei get _value => super._value as Narikei;
}

/// @nodoc

class _$Narikei extends Narikei {
  const _$Narikei() : super._();

  @override
  String toString() {
    return 'Piece.narikei()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Narikei);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return narikei();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return narikei?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (narikei != null) {
      return narikei();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return narikei(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return narikei?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (narikei != null) {
      return narikei(this);
    }
    return orElse();
  }
}

abstract class Narikei extends Piece {
  const factory Narikei() = _$Narikei;
  const Narikei._() : super._();
}

/// @nodoc
abstract class $GinshoCopyWith<$Res> {
  factory $GinshoCopyWith(Ginsho value, $Res Function(Ginsho) then) =
      _$GinshoCopyWithImpl<$Res>;
}

/// @nodoc
class _$GinshoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $GinshoCopyWith<$Res> {
  _$GinshoCopyWithImpl(Ginsho _value, $Res Function(Ginsho) _then)
      : super(_value, (v) => _then(v as Ginsho));

  @override
  Ginsho get _value => super._value as Ginsho;
}

/// @nodoc

class _$Ginsho extends Ginsho {
  const _$Ginsho() : super._();

  @override
  String toString() {
    return 'Piece.ginsho()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Ginsho);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return ginsho();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return ginsho?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (ginsho != null) {
      return ginsho();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return ginsho(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return ginsho?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (ginsho != null) {
      return ginsho(this);
    }
    return orElse();
  }
}

abstract class Ginsho extends Piece {
  const factory Ginsho() = _$Ginsho;
  const Ginsho._() : super._();
}

/// @nodoc
abstract class $NariginCopyWith<$Res> {
  factory $NariginCopyWith(Narigin value, $Res Function(Narigin) then) =
      _$NariginCopyWithImpl<$Res>;
}

/// @nodoc
class _$NariginCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $NariginCopyWith<$Res> {
  _$NariginCopyWithImpl(Narigin _value, $Res Function(Narigin) _then)
      : super(_value, (v) => _then(v as Narigin));

  @override
  Narigin get _value => super._value as Narigin;
}

/// @nodoc

class _$Narigin extends Narigin {
  const _$Narigin() : super._();

  @override
  String toString() {
    return 'Piece.narigin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Narigin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return narigin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return narigin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (narigin != null) {
      return narigin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return narigin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return narigin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (narigin != null) {
      return narigin(this);
    }
    return orElse();
  }
}

abstract class Narigin extends Piece {
  const factory Narigin() = _$Narigin;
  const Narigin._() : super._();
}

/// @nodoc
abstract class $HishaCopyWith<$Res> {
  factory $HishaCopyWith(Hisha value, $Res Function(Hisha) then) =
      _$HishaCopyWithImpl<$Res>;
}

/// @nodoc
class _$HishaCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $HishaCopyWith<$Res> {
  _$HishaCopyWithImpl(Hisha _value, $Res Function(Hisha) _then)
      : super(_value, (v) => _then(v as Hisha));

  @override
  Hisha get _value => super._value as Hisha;
}

/// @nodoc

class _$Hisha extends Hisha {
  const _$Hisha() : super._();

  @override
  String toString() {
    return 'Piece.hisha()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Hisha);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return hisha();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return hisha?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (hisha != null) {
      return hisha();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return hisha(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return hisha?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (hisha != null) {
      return hisha(this);
    }
    return orElse();
  }
}

abstract class Hisha extends Piece {
  const factory Hisha() = _$Hisha;
  const Hisha._() : super._();
}

/// @nodoc
abstract class $RyuoCopyWith<$Res> {
  factory $RyuoCopyWith(Ryuo value, $Res Function(Ryuo) then) =
      _$RyuoCopyWithImpl<$Res>;
}

/// @nodoc
class _$RyuoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $RyuoCopyWith<$Res> {
  _$RyuoCopyWithImpl(Ryuo _value, $Res Function(Ryuo) _then)
      : super(_value, (v) => _then(v as Ryuo));

  @override
  Ryuo get _value => super._value as Ryuo;
}

/// @nodoc

class _$Ryuo extends Ryuo {
  const _$Ryuo() : super._();

  @override
  String toString() {
    return 'Piece.ryuo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Ryuo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return ryuo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return ryuo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (ryuo != null) {
      return ryuo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return ryuo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return ryuo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (ryuo != null) {
      return ryuo(this);
    }
    return orElse();
  }
}

abstract class Ryuo extends Piece {
  const factory Ryuo() = _$Ryuo;
  const Ryuo._() : super._();
}

/// @nodoc
abstract class $KakugyoCopyWith<$Res> {
  factory $KakugyoCopyWith(Kakugyo value, $Res Function(Kakugyo) then) =
      _$KakugyoCopyWithImpl<$Res>;
}

/// @nodoc
class _$KakugyoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $KakugyoCopyWith<$Res> {
  _$KakugyoCopyWithImpl(Kakugyo _value, $Res Function(Kakugyo) _then)
      : super(_value, (v) => _then(v as Kakugyo));

  @override
  Kakugyo get _value => super._value as Kakugyo;
}

/// @nodoc

class _$Kakugyo extends Kakugyo {
  const _$Kakugyo() : super._();

  @override
  String toString() {
    return 'Piece.kakugyo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Kakugyo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return kakugyo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return kakugyo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (kakugyo != null) {
      return kakugyo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return kakugyo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return kakugyo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (kakugyo != null) {
      return kakugyo(this);
    }
    return orElse();
  }
}

abstract class Kakugyo extends Piece {
  const factory Kakugyo() = _$Kakugyo;
  const Kakugyo._() : super._();
}

/// @nodoc
abstract class $RyumaCopyWith<$Res> {
  factory $RyumaCopyWith(Ryuma value, $Res Function(Ryuma) then) =
      _$RyumaCopyWithImpl<$Res>;
}

/// @nodoc
class _$RyumaCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $RyumaCopyWith<$Res> {
  _$RyumaCopyWithImpl(Ryuma _value, $Res Function(Ryuma) _then)
      : super(_value, (v) => _then(v as Ryuma));

  @override
  Ryuma get _value => super._value as Ryuma;
}

/// @nodoc

class _$Ryuma extends Ryuma {
  const _$Ryuma() : super._();

  @override
  String toString() {
    return 'Piece.ryuma()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Ryuma);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return ryuma();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return ryuma?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (ryuma != null) {
      return ryuma();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return ryuma(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return ryuma?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (ryuma != null) {
      return ryuma(this);
    }
    return orElse();
  }
}

abstract class Ryuma extends Piece {
  const factory Ryuma() = _$Ryuma;
  const Ryuma._() : super._();
}

/// @nodoc
abstract class $KinshoCopyWith<$Res> {
  factory $KinshoCopyWith(Kinsho value, $Res Function(Kinsho) then) =
      _$KinshoCopyWithImpl<$Res>;
}

/// @nodoc
class _$KinshoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $KinshoCopyWith<$Res> {
  _$KinshoCopyWithImpl(Kinsho _value, $Res Function(Kinsho) _then)
      : super(_value, (v) => _then(v as Kinsho));

  @override
  Kinsho get _value => super._value as Kinsho;
}

/// @nodoc

class _$Kinsho extends Kinsho {
  const _$Kinsho() : super._();

  @override
  String toString() {
    return 'Piece.kinsho()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Kinsho);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return kinsho();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return kinsho?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (kinsho != null) {
      return kinsho();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return kinsho(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return kinsho?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (kinsho != null) {
      return kinsho(this);
    }
    return orElse();
  }
}

abstract class Kinsho extends Piece {
  const factory Kinsho() = _$Kinsho;
  const Kinsho._() : super._();
}

/// @nodoc
abstract class $OushoCopyWith<$Res> {
  factory $OushoCopyWith(Ousho value, $Res Function(Ousho) then) =
      _$OushoCopyWithImpl<$Res>;
}

/// @nodoc
class _$OushoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $OushoCopyWith<$Res> {
  _$OushoCopyWithImpl(Ousho _value, $Res Function(Ousho) _then)
      : super(_value, (v) => _then(v as Ousho));

  @override
  Ousho get _value => super._value as Ousho;
}

/// @nodoc

class _$Ousho extends Ousho {
  const _$Ousho() : super._();

  @override
  String toString() {
    return 'Piece.ousho()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Ousho);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return ousho();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return ousho?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (ousho != null) {
      return ousho();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return ousho(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return ousho?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (ousho != null) {
      return ousho(this);
    }
    return orElse();
  }
}

abstract class Ousho extends Piece {
  const factory Ousho() = _$Ousho;
  const Ousho._() : super._();
}

/// @nodoc
abstract class $GyokushoCopyWith<$Res> {
  factory $GyokushoCopyWith(Gyokusho value, $Res Function(Gyokusho) then) =
      _$GyokushoCopyWithImpl<$Res>;
}

/// @nodoc
class _$GyokushoCopyWithImpl<$Res> extends _$PieceCopyWithImpl<$Res>
    implements $GyokushoCopyWith<$Res> {
  _$GyokushoCopyWithImpl(Gyokusho _value, $Res Function(Gyokusho) _then)
      : super(_value, (v) => _then(v as Gyokusho));

  @override
  Gyokusho get _value => super._value as Gyokusho;
}

/// @nodoc

class _$Gyokusho extends Gyokusho {
  const _$Gyokusho() : super._();

  @override
  String toString() {
    return 'Piece.gyokusho()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Gyokusho);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() huhyo,
    required TResult Function() tokin,
    required TResult Function() kyosha,
    required TResult Function() narikyo,
    required TResult Function() keima,
    required TResult Function() narikei,
    required TResult Function() ginsho,
    required TResult Function() narigin,
    required TResult Function() hisha,
    required TResult Function() ryuo,
    required TResult Function() kakugyo,
    required TResult Function() ryuma,
    required TResult Function() kinsho,
    required TResult Function() ousho,
    required TResult Function() gyokusho,
  }) {
    return gyokusho();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
  }) {
    return gyokusho?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? huhyo,
    TResult Function()? tokin,
    TResult Function()? kyosha,
    TResult Function()? narikyo,
    TResult Function()? keima,
    TResult Function()? narikei,
    TResult Function()? ginsho,
    TResult Function()? narigin,
    TResult Function()? hisha,
    TResult Function()? ryuo,
    TResult Function()? kakugyo,
    TResult Function()? ryuma,
    TResult Function()? kinsho,
    TResult Function()? ousho,
    TResult Function()? gyokusho,
    required TResult orElse(),
  }) {
    if (gyokusho != null) {
      return gyokusho();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Huhyo value) huhyo,
    required TResult Function(Tokin value) tokin,
    required TResult Function(Kyosha value) kyosha,
    required TResult Function(Narikyo value) narikyo,
    required TResult Function(Keima value) keima,
    required TResult Function(Narikei value) narikei,
    required TResult Function(Ginsho value) ginsho,
    required TResult Function(Narigin value) narigin,
    required TResult Function(Hisha value) hisha,
    required TResult Function(Ryuo value) ryuo,
    required TResult Function(Kakugyo value) kakugyo,
    required TResult Function(Ryuma value) ryuma,
    required TResult Function(Kinsho value) kinsho,
    required TResult Function(Ousho value) ousho,
    required TResult Function(Gyokusho value) gyokusho,
  }) {
    return gyokusho(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
  }) {
    return gyokusho?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Huhyo value)? huhyo,
    TResult Function(Tokin value)? tokin,
    TResult Function(Kyosha value)? kyosha,
    TResult Function(Narikyo value)? narikyo,
    TResult Function(Keima value)? keima,
    TResult Function(Narikei value)? narikei,
    TResult Function(Ginsho value)? ginsho,
    TResult Function(Narigin value)? narigin,
    TResult Function(Hisha value)? hisha,
    TResult Function(Ryuo value)? ryuo,
    TResult Function(Kakugyo value)? kakugyo,
    TResult Function(Ryuma value)? ryuma,
    TResult Function(Kinsho value)? kinsho,
    TResult Function(Ousho value)? ousho,
    TResult Function(Gyokusho value)? gyokusho,
    required TResult orElse(),
  }) {
    if (gyokusho != null) {
      return gyokusho(this);
    }
    return orElse();
  }
}

abstract class Gyokusho extends Piece {
  const factory Gyokusho() = _$Gyokusho;
  const Gyokusho._() : super._();
}
